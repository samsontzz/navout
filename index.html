<!DOCTYPE html>
<html>
<head>
  <title>AR Navigation with Spheres Every 10 Meters using OpenStreetMap</title>
  <!-- Include A-Frame -->
  <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
  <!-- Include AR.js for A-Frame -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  <!-- Include Polyline Decoder for OSRM -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/polyline/1.1.1/polyline.js"></script>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; }
    #controls { padding: 10px; background: white; position: absolute; top: 0; left: 0; z-index: 1; }
    #ar-scene { height: 100%; width: 100%; }
  </style>
</head>
<body>
  <!-- Input form for start and destination -->
  <div id="controls">
    <input type="text" id="start" placeholder="Starting Point">
    <input type="text" id="end" placeholder="Destination Point">
    <button onclick="calculateRoute()">Go</button>
  </div>
  <!-- AR scene -->
  <a-scene embedded arjs='sourceType: webcam;' id="ar-scene">
    <a-camera gps-camera rotation-reader></a-camera>
  </a-scene>
  <!-- Script -->
  <script>
    function init() {
      // Optionally, get user's current location
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(function(position) {
          var pos = [position.coords.latitude, position.coords.longitude];
          console.log('User location:', pos);
        }, function() {
          handleLocationError(true);
        });
      } else {
        // Browser doesn't support Geolocation
        handleLocationError(false);
      }
    }

    function handleLocationError(browserHasGeolocation) {
      console.log(browserHasGeolocation ?
        'Error: The Geolocation service failed.' :
        'Error: Your browser doesn\'t support geolocation.');
    }

    async function calculateRoute() {
      var start = document.getElementById('start').value;
      var end = document.getElementById('end').value;

      // Geocode start and end locations using Nominatim API
      try {
        var startCoords = await geocode(start);
        var endCoords = await geocode(end);

        // Request route from OSRM
        var routeData = await getRoute(startCoords, endCoords);

        // Decode polyline to get path coordinates
        var path = decodePolyline(routeData.routes[0].geometry);

        // Now, process the route to get points every 10 meters
        var samples = samplePath(path, 10); // sample every 10 meters
        placeSpheres(samples);
      } catch (error) {
        console.log(error);
      }
    }

    function geocode(query) {
      return new Promise(function(resolve, reject) {
        var url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`;
        fetch(url)
          .then(response => response.json())
          .then(data => {
            if (data && data.length > 0) {
              var coords = [parseFloat(data[0].lat), parseFloat(data[0].lon)];
              resolve(coords);
            } else {
              reject('No results found for ' + query);
            }
          })
          .catch(error => reject(error));
      });
    }

    function getRoute(startCoords, endCoords) {
      return new Promise(function(resolve, reject) {
        var url = `https://router.project-osrm.org/route/v1/foot/${startCoords[1]},${startCoords[0]};${endCoords[1]},${endCoords[0]}?overview=full&geometries=polyline&steps=false`;
        fetch(url)
          .then(response => response.json())
          .then(data => {
            if (data && data.routes && data.routes.length > 0) {
              resolve(data);
            } else {
              reject('No route found');
            }
          })
          .catch(error => reject(error));
      });
    }

    function decodePolyline(polylineStr) {
      return polyline.decode(polylineStr).map(function(coords) {
        return [coords[0], coords[1]];
      });
    }

    function deg2rad(deg) {
      return deg * (Math.PI / 180);
    }

    function getDistanceFromLatLonInMeters(lat1, lon1, lat2, lon2) {
      var R = 6371000; // Radius of the earth in meters
      var dLat = deg2rad(lat2 - lat1);
      var dLon = deg2rad(lon2 - lon1);
      var a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2)
        ;
      var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      var d = R * c; // Distance in meters
      return d;
    }

    function interpolateCoords(lat1, lon1, lat2, lon2, fraction) {
      var lat = lat1 + (lat2 - lat1) * fraction;
      var lon = lon1 + (lon2 - lon1) * fraction;
      return [lat, lon];
    }

    function samplePath(path, interval) {
      var samples = [];
      var accumulatedDistance = 0;

      for (var i = 1; i < path.length; i++) {
        var segmentStart = path[i - 1];
        var segmentEnd = path[i];
        var segmentDistance = getDistanceFromLatLonInMeters(segmentStart[0], segmentStart[1], segmentEnd[0], segmentEnd[1]);

        while (accumulatedDistance + segmentDistance >= interval) {
          var remainingDistance = interval - accumulatedDistance;
          var fraction = remainingDistance / segmentDistance;
          var interpolatedPoint = interpolateCoords(
            segmentStart[0], segmentStart[1],
            segmentEnd[0], segmentEnd[1],
            fraction
          );
          samples.push(interpolatedPoint);

          // Prepare for next segment
          segmentStart = interpolatedPoint;
          segmentDistance = getDistanceFromLatLonInMeters(segmentStart[0], segmentStart[1], segmentEnd[0], segmentEnd[1]);
          accumulatedDistance = 0;
        }
        accumulatedDistance += segmentDistance;
      }
      return samples;
    }

    function placeSpheres(samples) {
      var scene = document.querySelector('a-scene');

      // Remove existing spheres if any
      var existingSpheres = document.querySelectorAll('.waypoint');
      existingSpheres.forEach(function(sphere) {
        sphere.parentNode.removeChild(sphere);
      });

      samples.forEach(function(coords) {
        var entity = document.createElement('a-sphere');
        entity.setAttribute('gps-entity-place', `latitude: ${coords[0]}; longitude: ${coords[1]};`);
        entity.setAttribute('material', 'color: red;');
        entity.setAttribute('radius', 1);
        entity.setAttribute('scale', '5 5 5');
        entity.setAttribute('class', 'waypoint');
        scene.appendChild(entity);
      });
    }

    // Call init when page loads
    window.onload = init;
  </script>
</body>
</html>
